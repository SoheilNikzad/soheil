<!DOCTYPE html>
<html lang="en">
<head>
Â  <meta charset="UTF-8">
Â  <title>ECIES Demo - Fixed CDN</title>
Â  Â  <script src="https://unpkg.com/@noble/secp256k1@1.7.1/lib/index.min.js"></script>
Â  <script src="https://cdn.jsdelivr.net/npm/crypto-js@4.1.1/crypto-js.js"></script>
Â  <style>
Â  Â  body { font-family: monospace; padding: 20px; background: #f7f7f7; }
Â  Â  pre { background: white; padding: 10px; border-radius: 6px; overflow-x: auto; }
Â  Â  button { padding: 10px; margin-top: 10px; }
Â  </style>
</head>
<body>
Â  <h2>ğŸ” ECIES Encryption Demo (Fixed CDN)</h2>
Â  <button onclick="runECIES()">Run Fixed Simulation</button>
Â  <pre id="output">Loadingâ€¦</pre>

Â  <script type="module">
Â  Â  // Make sure 'secp' is globally available if 'type="module"' is used and it's not imported.
Â  Â  // Or, you need to export 'runECIES' and call it properly.
Â  Â  // For simplicity, let's remove 'type="module"' for now if not strictly needed,
Â  Â  // and ensure secp is loaded globally.

Â  Â  // If you intend to use modules, you need to properly import secp inside the script where it's used.
Â  Â  // Let's keep it simple for now, making sure secp is available via window.nobleSecp256k1 or similar,
Â  Â  // as this CDN usually exposes it.
Â  Â  const secp = window.nobleSecp256k1; // Access the global object if the CDN exposes it like this.
                                    // If not, we might need a different import strategy or a different CDN.
                                    // Let's assume unpkg.com makes it available. If it still fails,
                                    // we'll explicitly use 'import * as secp from "..."' inside the script tag.

    // A safer way if the module import isn't working as expected.
    // However, the previous approach with type="module" and direct import should work if the CDN path is right.
    // Let's revert to the previous import style if this doesn't work, and fix the CDN path.

    // Let's try the correct module import for noble-secp256k1 as it's designed to be used.
    // The previous code had a correct import statement in the <script type="module"> block,
    // the issue was specifically the CDN URL.

    // This is the correct way to import noble-secp256k1 for modern browsers:
    // import * as secp from "https://unpkg.com/@noble/secp256k1@1.7.1/lib/index.min.js";
    // However, for <script type="module"> this needs to be inside the runECIES function
    // or the module script itself, and 'runECIES' needs to be called after it's defined and imported.

    // Let's rewrite the script tag to ensure the module is imported correctly within the function scope if needed,
    // or globally if the CDN supports it.
    // For now, I'll put the import statement directly into the `runECIES` function or the global scope if possible
    // to ensure it runs *after* the library is loaded.

    // The error "runECIES is not defined" implies the script tag type="module" caused runECIES to be in a module scope,
    // while the onclick attribute expects it to be in the global scope.
    // Two solutions:
    // 1. Remove type="module" from the script tag and ensure noble-secp256k1 makes 'secp' global.
    // 2. Keep type="module" but call runECIES differently (e.g., expose it to window).

    // Let's go with solution 2, as it's cleaner for modern JS.
    // And fix the CDN URL.

    // Remove the global import. Put it inside runECIES or at the top of the module script.
    // We'll put it at the top of the module script and then expose runECIES.
    
    // Correct import for noble-secp256k1 as a module:
    import { getPublicKey, utils } from "https://unpkg.com/@noble/secp256k1@1.7.1/lib/index.min.js";
    // Correct import for CryptoJS as a module:
    import CryptoJS from "https://cdn.jsdelivr.net/npm/crypto-js@4.1.1/+esm";


Â  Â  async function runECIES() {
Â  Â  Â  const outputDiv = document.getElementById("output");
Â  Â  Â  outputDiv.innerText = "â³ Running simulation...";

Â  Â  Â  // Helper function to convert bytes to hex (from previous conversation)
Â  Â  Â  const bytesToHex = (bytes) => Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');

Â  Â  Â  // 1. ØªÙˆÙ„ÛŒØ¯ Ú©Ù„ÛŒØ¯Ù‡Ø§ÛŒ Alice (ÙØ±Ø³ØªÙ†Ø¯Ù‡) Ùˆ Bob (Ú¯ÛŒØ±Ù†Ø¯Ù‡)
Â  Â  Â  const alicePrivateKey = utils.randomPrivateKey();
Â  Â  Â  const alicePublicKey = getPublicKey(alicePrivateKey);

Â  Â  Â  const bobPrivateKey = utils.randomPrivateKey();
Â  Â  Â  const bobPublicKey = getPublicKey(bobPrivateKey);

Â  Â  Â  // 2. Ù…Ø­Ø§Ø³Ø¨Ù‡ Shared Secret Ø§Ø² Ø¯ÛŒØ¯ Alice: privA * pubB (Ø¨Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² ECDH)
Â  Â  Â  const sharedSecretAliceView = await nobleSecp256k1.getSharedSecret(alicePrivateKey, bobPublicKey);

Â  Â  Â  // 3. Ù‡Ø´ Ú©Ø±Ø¯Ù† Shared Secret Ø¨Ø±Ø§ÛŒ ØªÙˆÙ„ÛŒØ¯ Ú©Ù„ÛŒØ¯ AES (SHA256)
Â  Â  Â  const aesKeyAlice = CryptoJS.SHA256(CryptoJS.enc.Hex.parse(bytesToHex(sharedSecretAliceView))).toString();

Â  Â  Â  // 4. Ù¾ÛŒØ§Ù… Ùˆ IV
Â  Â  Â  const message = "Hello Dear Ehsan! This is a secure message.";
Â  Â  Â  const ivBytes = crypto.getRandomValues(new Uint8Array(16)); // 16 Ø¨Ø§ÛŒØª IV ØªØµØ§Ø¯ÙÛŒ
Â  Â  Â  const iv = CryptoJS.enc.Hex.parse(bytesToHex(ivBytes)); // ØªØ¨Ø¯ÛŒÙ„ Ø¨Ù‡ WordArray

Â  Â  Â  // 5. Ø±Ù…Ø²Ù†Ú¯Ø§Ø±ÛŒ Ù¾ÛŒØ§Ù… Ø¨Ø§ AES-256-CBC
Â  Â  Â  const encrypted = CryptoJS.AES.encrypt(
Â  Â  Â  Â  message,
Â  Â  Â  Â  CryptoJS.enc.Hex.parse(aesKeyAlice), // Ú©Ù„ÛŒØ¯ AES
Â  Â  Â  Â  {
Â  Â  Â  Â  Â  iv: iv,
Â  Â  Â  Â  Â  mode: CryptoJS.mode.CBC,
Â  Â  Â  Â  Â  padding: CryptoJS.pad.Pkcs7,
Â  Â  Â  Â  }
Â  Â  Â  );

Â  Â  Â  // 6. Ù…Ø­Ø§Ø³Ø¨Ù‡ Shared Secret Ø§Ø² Ø¯ÛŒØ¯ Bob: privB * pubA
Â  Â  Â  const sharedSecretBobView = await nobleSecp256k1.getSharedSecret(bobPrivateKey, alicePublicKey);
Â  Â  Â  const aesKeyBob = CryptoJS.SHA256(CryptoJS.enc.Hex.parse(bytesToHex(sharedSecretBobView))).toString();

Â  Â  Â  // 7. Ø±Ù…Ø²Ú¯Ø´Ø§ÛŒÛŒ Ù¾ÛŒØ§Ù… Ø§Ø² Ø³Ù…Øª Bob
Â  Â  Â  const decrypted = CryptoJS.AES.decrypt(
Â  Â  Â  Â  encrypted.toString(), // encrypted.toString() Ø¨Ø±Ø§ÛŒ Ú¯Ø±ÙØªÙ† string Ú©Ø§Ù…Ù„ Ø´Ø§Ù…Ù„ cipher + salt + iv
Â  Â  Â  Â  CryptoJS.enc.Hex.parse(aesKeyBob),
Â  Â  Â  Â  {
Â  Â  Â  Â  Â  iv: iv,
Â  Â  Â  Â  Â  mode: CryptoJS.mode.CBC,
Â  Â  Â  Â  Â  padding: CryptoJS.pad.Pkcs7,
Â  Â  Â  Â  }
Â  Â  Â  );

Â  Â  Â  outputDiv.innerHTML = `
<pre>
ğŸ” Alice Private Key: ${secp.utils.bytesToHex(alicePrivateKey)}
ğŸ”“ Alice Public Key : ${secp.utils.bytesToHex(alicePublicKey)}

ğŸ”‘ Bob Private KeyÂ  : ${secp.utils.bytesToHex(bobPrivateKey)}
ğŸ”“ Bob Public KeyÂ  Â : ${secp.utils.bytesToHex(bobPublicKey)}

---
Shared Secret (Alice's View): ${secp.utils.bytesToHex(sharedSecretAliceView)}
Shared Secret (Bob's View): Â  ${secp.utils.bytesToHex(sharedSecretBobView)}
âœ… Shared Secrets Match? ${secp.utils.bytesToHex(sharedSecretAliceView) === secp.utils.bytesToHex(sharedSecretBobView)}

---
ğŸ”‘ AES Key (from Alice's SS): ${aesKeyAlice}
ğŸ”‘ AES Key (from Bob's SS): Â  ${aesKeyBob}
âœ… AES Keys Match? ${aesKeyAlice === aesKeyBob}

---
ğŸ“¨ Original Message: ${message}
ğŸ§Š IV (Initialization Vector): ${secp.utils.bytesToHex(ivBytes)}
ğŸ” Encrypted Message (Ciphertext): ${encrypted.ciphertext.toString(CryptoJS.enc.Hex)}

---
ğŸ“¬ Decrypted Message (by Bob): ${decrypted.toString(CryptoJS.enc.Utf8)}
âœ… Decryption Successful? ${message === decrypted.toString(CryptoJS.enc.Utf8)}
</pre>`;
Â  Â  }

Â  Â  // Export runECIES to the global window object so it can be called by onclick
Â  Â  window.runECIES = runECIES;

Â  Â  // Run on page load
Â  Â  document.addEventListener('DOMContentLoaded', runECIES);
Â  </script>
</body>
</html>
