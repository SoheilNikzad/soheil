<!doctype html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="utf-8" />
  <title>cmx — on-chain comic editor (static)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Comfortaa:wght@300&family=Vazirmatn:wght@300&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg:#0b0c0f; --panel:#11131a; --fg:#e7e7e7; --muted:#9fb0c8;
      --border:#1c2030; --btn:#1e2436; --btn2:#262d47;
      --accent:#ff7a00; --accent2:#ff9933;
      --ok:#1db954; --warn:#ffcc00; --err:#ff4d4f;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);
      font-family:'Vazirmatn',sans-serif; font-weight:300}
    .en, .kbd, button, .brand, .addr{font-family:'Comfortaa',sans-serif!important;font-weight:300}

    .wrap{display:grid;grid-template-columns:1fr 440px;gap:16px;min-height:100vh;padding:16px}
    header{grid-column:1/-1;display:flex;align-items:center;justify-content:space-between;
      padding:8px 0 14px;border-bottom:1px solid var(--border);gap:12px;flex-wrap:wrap}
    .title{font-weight:700;letter-spacing:.3px}
    .brand{opacity:.85;font-size:12px}
    .brand a{color:var(--muted);text-decoration:none}.brand a:hover{text-decoration:underline}

    .walletbar{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    select, input[type="text"]{
      background:#0f1220;border:1px solid #2a3350;border-radius:10px;padding:8px 10px;color:#cbd3df}
    .connect{background:linear-gradient(180deg,var(--accent),var(--accent2)); color:#1b1106;
      border:none;border-radius:10px;padding:10px 14px;cursor:pointer}
    .connect[disabled]{opacity:.8;cursor:default}
    .connect:hover:not([disabled]){filter:brightness(1.05)}
    .pill{border:1px solid #2a3350;border-radius:999px;padding:6px 10px;color:#cbd3df;font-size:12px}
    .addr{background:#151b2a}

    .pane{background:var(--panel);border:1px solid var(--border);border-radius:12px;overflow:hidden;display:flex;flex-direction:column}
    .pane h3{margin:0;padding:12px 14px;border-bottom:1px solid var(--border);color:#cbd3df;font-size:14px}
    .preview{padding:12px;flex:1;overflow:auto}
    .preview .host{display:flex;align-items:center;justify-content:center;min-height:380px}
    .editor{position:relative;min-height:460px}
    #editor{position:absolute;inset:0;font-size:13px}

    .toolbar{display:flex;flex-wrap:wrap;gap:8px;align-items:center;padding:10px 12px;border-top:1px solid var(--border);background:#0f1220}
    .btn{background:var(--btn);color:#cbd3df;border:1px solid #2a3350;border-radius:10px;padding:8px 12px;cursor:pointer}
    .btn:hover{background:var(--btn2)}
    .btn-accent{background:linear-gradient(180deg,var(--accent),var(--accent2));color:#1b1106;border:none}
    .kbd{display:inline-block;background:#1a1f33;border:1px solid #2f3a5d;border-radius:6px;padding:0 6px;margin:0 2px}
    .hint{padding:8px 12px;color:var(--muted);font-size:12px;border-top:1px dashed #24304d;background:#0f1324}

    .ghost{pointer-events:none;position:fixed;left:8px;bottom:8px;background:#111a;border:1px solid #333;
      padding:6px 8px;border-radius:8px;font-size:12px}
    .handle{fill:#4ad;stroke:#024;stroke-width:1.5;cursor:grab}
    .handle:active{cursor:grabbing}

    @media(max-width:1100px){.wrap{grid-template-columns:1fr}}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="brand">Inspired by <a href="https://github.com/darwin/cmx.js" target="_blank" rel="noopener">cmx.js</a></div>
      <div class="title en">cmx — on-chain comic editor</div>

      <div class="walletbar">
        <select id="chain" title="Network">
          <option value="0xaa36a7">Ethereum Sepolia</option>
          <option value="0x89">Polygon Mainnet</option>
          <option value="0x13882">Polygon Amoy (test)</option>
          <option value="0x1a4">Optimism Sepolia</option>
          <option value="0xa869">Avalanche Fuji</option>
        </select>
        <button id="btn-switch" class="btn en">Switch</button>
        <button id="btn-connect" class="connect en">Connect Wallet</button>
      </div>
    </header>

    <section class="pane">
      <h3>پیش‌نمایش (تک‌کلیک=جابجایی، دابل‌کلیک=ویرایش مفصل‌ها)</h3>
      <div id="preview" class="preview"><div id="host" class="host"></div></div>
      <div class="log" id="log" style="margin-top:8px;font-size:12px;color:#b8c4d6"></div>
    </section>

    <section class="pane">
      <h3>ویرایشگر</h3>
      <div class="editor"><div id="editor"></div></div>

      <div class="toolbar">
        <button id="btn-run" class="btn en">Render (⏎)</button>
        <button id="btn-reset" class="btn en">Reset</button>
        <span class="brand">Samples:</span>
        <button class="btn en" data-sample="s1">Sample A</button>
        <button class="btn en" data-sample="s2">Sample B</button>
        <button class="btn en" data-sample="s3">Sample C</button>
      </div>

      <div class="toolbar">
        <input id="comicName" type="text" class="en" placeholder="comic name (optional)" style="min-width:180px">
        <button id="btn-save" class="btn-accent en">Save on-chain</button>
        <input id="txhash" type="text" class="en" placeholder="0x… transaction hash" style="flex:1;min-width:240px">
        <button id="btn-load" class="btn en">Load by Tx Hash</button>
      </div>

      <div class="hint">
        دستورات: <span class="kbd">panel &lt;W&gt;x&lt;H&gt;</span>،
        <span class="kbd">stick x=… y=…</span>،
        <span class="kbd">say x=… y=… "متن"</span> — با کشیدن اشیاء، مختصات در ادیتور آپدیت می‌شود.  
        برای ذخیره روی زنجیره روی همان شبکه‌ای باش که می‌خواهی بخوانی.
      </div>
    </section>
  </div>

  <div id="ghost" class="ghost en" style="display:none;"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.32.6/ace.js" crossorigin="anonymous"></script>

  <script>
    /*********** setup ***********/
    const STROKE = 4; // خط باریک‌تر
    const $ = s => document.querySelector(s);
    const svgNS = 'http://www.w3.org/2000/svg';
    const ghost = $("#ghost"), log=$("#log");
    let currentParse=null, dragging=null, account=null;
    const poses = new Map(); // lineIndex -> pose

    const ethereum = window.ethereum;
    const toHex = (str) => '0x' + [...new TextEncoder().encode(str)].map(b=>b.toString(16).padStart(2,'0')).join('');
    const fromHex = (hex) => {
      hex = (hex||'').replace(/^0x/, '');
      return new TextDecoder().decode(new Uint8Array(hex?hex.match(/.{1,2}/g).map(h=>parseInt(h,16)):[]));
    };
    const short = a => a ? a.slice(0,6)+'…'+a.slice(-4) : '';
    const tell = (msg,kind='info')=>{
      const color = kind==='ok'?'#1db954':kind==='warn'?'#ffcc00':kind==='err'?'#ff4d4f':'#9fb0c8';
      log.innerHTML = `<span style="color:${color}">${msg}</span>`;
    };

    /*********** SVG primitives ***********/
    function createSVG(w=800,h=400){
      const svg=document.createElementNS(svgNS,'svg');
      svg.setAttribute('viewBox',`0 0 ${w} ${h}`);
      svg.setAttribute('width',w); svg.setAttribute('height',h);
      svg.style.background='#fff'; svg.style.border='2px solid #000'; svg.style.borderRadius='8px';
      svg.addEventListener('mousemove',onDragMove);
      svg.addEventListener('touchmove',onDragMove,{passive:false});
      svg.addEventListener('mouseup',onDragEnd);
      svg.addEventListener('mouseleave',onDragEnd);
      svg.addEventListener('touchend',onDragEnd);
      return svg;
    }
    function lineP(g,x1,y1,x2,y2,sw=STROKE){ const ln=document.createElementNS(svgNS,'line');
      ln.setAttribute('x1',x1); ln.setAttribute('y1',y1);
      ln.setAttribute('x2',x2); ln.setAttribute('y2',y2);
      ln.setAttribute('stroke','#000'); ln.setAttribute('stroke-width',sw);
      ln.setAttribute('stroke-linecap','round'); g.appendChild(ln); }
    function circleP(g,cx,cy,r,fill='#000'){ const c=document.createElementNS(svgNS,'circle');
      c.setAttribute('cx',cx); c.setAttribute('cy',cy); c.setAttribute('r',r);
      c.setAttribute('fill',fill); g.appendChild(c); }

    /*********** Bubbles — precise sizing & layering ***********/
    function measureLineWidth(svg, text, isFa){
      // عنصر موقتی برای اندازه‌گیری
      const t = document.createElementNS(svgNS,'text');
      t.setAttribute('x', 0); t.setAttribute('y', -9999); // بیرون قاب
      t.setAttribute('font-size','16');
      t.setAttribute('font-family', isFa ? 'Vazirmatn' : 'Comfortaa');
      t.setAttribute('font-weight','300');
      t.setAttribute('direction', isFa ? 'rtl' : 'ltr');
      t.setAttribute('unicode-bidi', 'plaintext');
      t.textContent = text;
      svg.appendChild(t);
      const w = t.getBBox().width;
      t.remove();
      return w;
    }

    function drawSay(svg, op){
      const g=document.createElementNS(svgNS,'g');
      g.dataset.type='say'; g.dataset.line=op._line;

      const rawLines = op.text.replace(/\r/g,'').split(/\n/);
      const padding=12, rx=12, ry=12, lh=20, MAXW=380;

      // اندازه‌گیری دقیق خطوط با فونت واقعی
      const widths = rawLines.map(ln => measureLineWidth(svg, ln, /[\u0600-\u06FF]/.test(ln)));
      const maxMeasured = Math.max(...widths, 0);
      const width = Math.min(MAXW, padding*2 + Math.ceil(maxMeasured));
      const height = padding*2 + rawLines.length*lh;

      // ترتیب لایه‌ها: اول دم، بعد بدنه، بعد متن‌ها  (دم زیرِ بدنه می‌ماند)
      const tail=document.createElementNS(svgNS,'path');
      tail.setAttribute('d',`M ${op.x+24} ${op.y+height} l 14 18 l 6 -22 Z`);
      tail.setAttribute('fill','#fff'); tail.setAttribute('stroke','#000'); tail.setAttribute('stroke-width','2');
      g.appendChild(tail);

      const r=document.createElementNS(svgNS,'rect');
      r.setAttribute('x',op.x); r.setAttribute('y',op.y);
      r.setAttribute('width',width); r.setAttribute('height',height);
      r.setAttribute('rx',rx); r.setAttribute('ry',ry);
      r.setAttribute('fill','#fff'); r.setAttribute('stroke','#000'); r.setAttribute('stroke-width','2');
      g.appendChild(r);

      rawLines.forEach((ln,i)=>{
        const isFa = /[\u0600-\u06FF]/.test(ln);
        const t=document.createElementNS(svgNS,'text');
        t.setAttribute('x', op.x + padding);
        t.setAttribute('y', op.y + padding + (i+1)*lh - 6);
        t.setAttribute('font-size','16');
        t.setAttribute('font-family', isFa ? 'Vazirmatn' : 'Comfortaa');
        t.setAttribute('font-weight','300');
        t.setAttribute('fill','#000');
        t.setAttribute('direction', isFa ? 'rtl' : 'ltr');
        t.setAttribute('unicode-bidi', 'plaintext');
        t.textContent=ln;
        g.appendChild(t);
      });

      svg.appendChild(g);
      g.style.cursor='move';
      g.addEventListener('mousedown',ev=>startDrag(ev,g,op,'say-group'));
      g.addEventListener('touchstart',ev=>startDrag(ev,g,op,'say-group'),{passive:false});
    }

    /*********** Stick figure (better proportions) ***********/
    function defaultPose(x,y){
      const forearm = 28, upperArm = 26;
      const torso = Math.max(Math.round(forearm*0.5), 30);
      const headR = 14;
      return {
        head:{x:x, y:y-(torso+headR+8)}, neck:{x:x, y:y-(torso+8)}, shoulder:{x:x, y:y-(torso-6)},
        elbowL:{x:x-upperArm, y:y-(torso-6)+10}, wristL:{x:x-upperArm-forearm, y:y-(torso-6)+24},
        elbowR:{x:x+upperArm, y:y-(torso-6)+10}, wristR:{x:x+upperArm+forearm, y:y-(torso-6)+24},
        hip:{x:x, y:y},
        kneeL:{x:x-16, y:y+34}, ankleL:{x:x-26, y:y+74},
        kneeR:{x:x+16, y:y+34}, ankleR:{x:x+26, y:y+74},
        headR
      };
    }

    function drawBonesOn(group, pose){
      let bones = group.querySelector('.bones');
      if(!bones){ bones=document.createElementNS(svgNS,'g'); bones.classList.add('bones'); group.appendChild(bones); }
      bones.innerHTML='';
      circleP(bones, pose.head.x, pose.head.y, pose.headR);
      lineP(bones, pose.head.x, pose.head.y+pose.headR, pose.neck.x, pose.neck.y, STROKE);
      lineP(bones, pose.neck.x, pose.neck.y, pose.hip.x, pose.hip.y+2, STROKE);
      lineP(bones, pose.shoulder.x, pose.shoulder.y, pose.elbowL.x, pose.elbowL.y, STROKE);
      lineP(bones, pose.elbowL.x, pose.elbowL.y, pose.wristL.x, pose.wristL.y, STROKE);
      lineP(bones, pose.shoulder.x, pose.shoulder.y, pose.elbowR.x, pose.elbowR.y, STROKE);
      lineP(bones, pose.elbowR.x, pose.elbowR.y, pose.wristR.x, pose.wristR.y, STROKE);
      lineP(bones, pose.hip.x, pose.hip.y, pose.kneeL.x, pose.kneeL.y, STROKE);
      lineP(bones, pose.kneeL.x, pose.kneeL.y, pose.ankleL.x, pose.ankleL.y, STROKE);
      lineP(bones, pose.hip.x, pose.hip.y, pose.kneeR.x, pose.kneeR.y, STROKE);
      lineP(bones, pose.kneeR.x, pose.kneeR.y, pose.ankleR.x, pose.ankleR.y, STROKE);
    }

    function drawStick(svg, op){
      let pose = poses.get(op._line); if(!pose){ pose = defaultPose(op.x, op.y); poses.set(op._line, pose); }
      const g=document.createElementNS(svgNS,'g');
      g.dataset.type='stick'; g.dataset.line = op._line;
      svg.appendChild(g);
      drawBonesOn(g, pose);

      g.style.cursor='move';
      g.addEventListener('mousedown',ev=>startDrag(ev,g,op,'stick-group'));
      g.addEventListener('touchstart',ev=>startDrag(ev,g,op,'stick-group'),{passive:false});
      g.addEventListener('dblclick',ev=>{ev.stopPropagation(); toggleHandles(g, op._line);});
      return g;
    }

    function toggleHandles(group, lineIndex){
      const existing = group.querySelector('.handles');
      if(existing){ existing.remove(); return; }
      const pose = poses.get(lineIndex);
      const handles = document.createElementNS(svgNS,'g');
      handles.classList.add('handles');
      group.appendChild(handles);

      Object.entries(pose).forEach(([key,pt])=>{
        if(key==='headR') return;
        const h=document.createElementNS(svgNS,'circle');
        h.setAttribute('cx', pt.x); h.setAttribute('cy', pt.y); h.setAttribute('r', 6);
        h.classList.add('handle'); h.dataset.key = key; h.dataset.line=lineIndex;
        handles.appendChild(h);
        h.addEventListener('mousedown', ev => startHandleDrag(ev, group, lineIndex, key, h));
        h.addEventListener('touchstart', ev => startHandleDrag(ev, group, lineIndex, key, h), {passive:false});
      });
    }

    /*********** Parser & Render ***********/
    function parse(src){
      const lines=src.split(/\r?\n/);
      let W=820,H=420; const ops=[];
      lines.forEach((raw,idx)=>{
        const s=raw.trim();
        if(!s || s.startsWith('#')) return;
        const cmd=s.split(/\s+/)[0], rest=s.slice(cmd.length).trim();
        if(cmd==='panel'){
          const m=rest.match(/(\d+)\s*x\s*(\d+)/i);
          if(m){ W=+m[1]; H=+m[2]; }
        }else if(cmd==='stick'){
          const m=Object.fromEntries([...rest.matchAll(/(\w+)\s*=\s*("[^"]*"|\S+)/g)].map(([_,k,v])=>[k,v.replace(/^"|"$/g,'')]));
          ops.push({_line:idx,t:'stick',x:+m.x||100,y:+m.y||160});
        }else if(cmd==='say'){
          const m=Object.fromEntries([...rest.matchAll(/(\w+)\s*=\s*("[^"]*"|\S+)/g)].map(([_,k,v])=>[k,v.replace(/^"|"$/g,'')]));
          const mtext=rest.match(/"([^"]*)"/);
          const text = mtext? mtext[1] : (m.text||'');
          ops.push({_line:idx,t:'say',x:+m.x||60,y:+m.y||60,text});
        }
      });
      return {W,H,ops,lines};
    }

    function render(src){
      currentParse = parse(src);
      const {W,H,ops} = currentParse;
      const host=$("#host"); host.innerHTML='';
      const svg=createSVG(W,H); host.appendChild(svg);
      ops.forEach(op=>{
        if(op.t==='stick') drawStick(svg, op);
        else if(op.t==='say') drawSay(svg, op);
      });
    }

    /*********** Drag logic ***********/
    function getSVGPoint(ev){
      const svg = $('#host svg'); if(!svg) return {x:0,y:0};
      const pt = svg.createSVGPoint();
      const src = ev.touches ? ev.touches[0] : ev;
      pt.x = src.clientX; pt.y = src.clientY;
      const m = svg.getScreenCTM().inverse();
      return pt.matrixTransform(m);
    }

    function startDrag(ev, g, op, kind){
      ev.preventDefault();
      const pt = getSVGPoint(ev);
      dragging = { kind, g, op, start:pt, moved:false };
      ghost.style.display='block';
      ghost.textContent = `${op.t}  x=${op.x}  y=${op.y}`;
    }
    function startHandleDrag(ev, group, lineIndex, key, handleEl){
      ev.preventDefault();
      const pt = getSVGPoint(ev);
      const pose = poses.get(lineIndex);
      dragging = { kind:'handle', group, lineIndex, key, start:pt, origin:{x:pose[key].x, y:pose[key].y}, handleEl };
      ghost.style.display='block'; ghost.textContent = `${key}`;
    }

    function onDragMove(ev){
      if(!dragging) return;
      ev.preventDefault();
      const pt = getSVGPoint(ev);
      const dx = pt.x - dragging.start.x;
      const dy = pt.y - dragging.start.y;

      if(dragging.kind==='stick-group' || dragging.kind==='say-group'){
        dragging.moved = true;
        dragging.g.setAttribute('transform', `translate(${dx},${dy})`);
        const label = dragging.kind==='stick-group'?'stick':'say';
        ghost.textContent = `${label} x=${dragging.op.x+Math.round(dx)} y=${dragging.op.y+Math.round(dy)}`;
      } else if(dragging.kind==='handle'){
        dragging.moved = true;
        const nx = Math.round(dragging.origin.x + dx);
        const ny = Math.round(dragging.origin.y + dy);
        const pose = poses.get(dragging.lineIndex);
        pose[dragging.key].x = nx; pose[dragging.key].y = ny;
        dragging.handleEl.setAttribute('cx', nx);
        dragging.handleEl.setAttribute('cy', ny);
        drawBonesOn(dragging.group, pose);
      }
    }

    function onDragEnd(){
      if(!dragging) return;
      ghost.style.display='none';

      if((dragging.kind==='stick-group' || dragging.kind==='say-group') && dragging.moved){
        const m = dragging.g.getAttribute('transform');
        const delta = m ? m.match(/translate\(([-\d.]+),([-\d.]+)\)/) : null;
        const dx = delta ? Math.round(parseFloat(delta[1])) : 0;
        const dy = delta ? Math.round(parseFloat(delta[2])) : 0;

        const line = dragging.op._line;
        if(dragging.kind==='stick-group'){
          const pose = poses.get(line) || defaultPose(dragging.op.x, dragging.op.y);
          Object.keys(pose).forEach(k=>{ if(k!=='headR'){ pose[k].x += dx; pose[k].y += dy; }});
          poses.set(line, pose);
        }
        applyXYToEditorLine(line, (dragging.op.x+dx), (dragging.op.y+dy));
      }

      dragging = null;
      run();
    }

    /*********** Editor ***********/
    const editor = ace.edit("editor");
    editor.setTheme("ace/theme/one_dark");
    editor.session.setMode("ace/mode/text");
    editor.session.setUseWrapMode(true);

    function applyXYToEditorLine(lineIndex, x, y){
      const session = editor.session;
      let line = session.getLine(lineIndex);
      if(!/x\s*=/.test(line)) line += ` x=${x}`;
      if(!/y\s*=/.test(line)) line += ` y=${y}`;
      line = line.replace(/x\s*=\s*("[^"]*"|-?\d+(\.\d+)?)/, `x=${x}`);
      line = line.replace(/y\s*=\s*("[^"]*"|-?\d+(\.\d+)?)/, `y=${y}`);
      session.replace({start:{row:lineIndex,column:0}, end:{row:lineIndex,column:session.getLine(lineIndex).length}}, line);
    }
    function run(){ render(editor.getValue()); }

    const samples = {
s1:`# Sample A — 4 sticks + 2 bubbles
panel 860x420
stick x=140 y=230
say   x=60  y=120 "سلام! به cmx خوش اومدی :)"
stick x=280 y=230
say   x=220 y=140 "اینجا همه‌چیز استاتیکه. فقط همین فایل رو منتشر کن!"
stick x=580 y=230
say   x=500 y=120 "Welcome to cmx! Minimal, static, fun."
stick x=720 y=230
say   x=640 y=140 "soheil.info/cmx"
`,
s2:`# Sample B — Two people talk
panel 800x420
stick x=200 y=220
say   x=120 y=120 "سلام Soheil! این پیش‌فرض آماده‌ست."
stick x=520 y=220
say   x=440 y=130 "اوکی، Enter رو بزن تا رندر شه یا متن رو تغییر بده."
`,
s3:`# Sample C — Minimal
panel 800x420
stick x=160 y=210
stick x=300 y=210
say x=80  y=120 "من یک آدمکم! متن طولانی هم داخل کادر می‌ماند و می‌شکند."
say x=240 y=130 "و من هم همین‌طور ✅"
`
    };

    editor.setValue(samples.s1, -1); run();
    $("#btn-run").onclick = run;
    $("#btn-reset").onclick = ()=>{ poses.clear(); editor.setValue(samples.s2, -1); run(); };
    document.querySelectorAll('[data-sample]').forEach(b=>{
      b.addEventListener('click',()=>{ poses.clear(); editor.setValue(samples[b.dataset.sample]||samples.s1, -1); run(); });
    });
    editor.commands.addCommand({name:'render',bindKey:{win:'Enter',mac:'Enter'},exec:run});

    /*********** Wallet (EIP-1193) ***********/
    async function connect(){
      if(!ethereum){ tell('Wallet/provider پیدا نشد.','err'); return; }
      try{
        const [addr] = await ethereum.request({method:'eth_requestAccounts'});
        account = addr;
        const btn = $("#btn-connect");
        btn.textContent = `Connected: ${short(addr)}`;
        btn.disabled = true;
        tell('Wallet connected.','ok');
      }catch(e){ tell('اتصال لغو شد.','warn'); }
    }
    async function switchChain(){
      if(!ethereum){ tell('Provider در دسترس نیست.','err'); return; }
      const chainId = $("#chain").value;
      try{
        await ethereum.request({method:'wallet_switchEthereumChain', params:[{chainId}]});
        tell('Switched network.','ok');
      }catch(e){ tell('Switch شکست خورد. شاید لازم است شبکه را دستی اضافه کنی.','warn'); }
    }
    async function saveToChain(){
      if(!ethereum){ tell('Provider در دسترس نیست.','err'); return; }
      if(!account){ await connect(); if(!account) return; }
      const name = $("#comicName").value.trim();
      const payload = { v:1, name, ts:Date.now(), dsl: editor.getValue().trim(), poses:Object.fromEntries([...poses.entries()]) };
      const hex = toHex(JSON.stringify(payload));
      try{
        const tx = await ethereum.request({method:'eth_sendTransaction', params:[{from:account,to:account,value:'0x0',data:hex}]});
        $("#txhash").value = tx; tell('Saved on chain. Tx: '+tx,'ok');
      }catch(e){
        // نمایش خطای واقعی متامسک
        tell((e && e.message) ? e.message : 'Tx rejected/failed.', 'err');
      }
    }
    async function loadFromTx(){
      if(!ethereum){ tell('Provider در دسترس نیست.','err'); return; }
      const txh = $("#txhash").value.trim();
      if(!/^0x([0-9a-fA-F]{64})$/.test(txh)){ tell('TX hash نامعتبر.','warn'); return; }
      try{
        const tx = await ethereum.request({method:'eth_getTransactionByHash', params:[txh]});
        if(!tx || !tx.input){ tell('Tx یا داده ندارد یا روی شبکهٔ دیگری هستی.','warn'); return; }
        const obj = JSON.parse(fromHex(tx.input)||'{}');
        poses.clear();
        if(obj.poses){ for(const [k,v] of Object.entries(obj.poses)){ poses.set(Number(k), v); } }
        editor.setValue(obj.dsl||'', -1);
        $("#comicName").value = obj.name||'';
        run(); tell('Loaded from chain.','ok');
      }catch(e){ tell((e && e.message)?e.message:'خواندن تراکنش ناموفق بود.','err'); }
    }
    $("#btn-connect").onclick = connect;
    $("#btn-switch").onclick = switchChain;
    $("#btn-save").onclick = saveToChain;
    $("#btn-load").onclick = loadFromTx;

    // ESC = بستن هندل‌ها
    document.addEventListener('keydown', e=>{ if(e.key==='Escape'){ const h=document.querySelector('.handles'); if(h) h.remove(); }});
  </script>
</body>
</html>
